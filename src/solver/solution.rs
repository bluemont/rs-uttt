use data::Play;
use solver::Outcome;

/// A solution (`Solution`) is generated by a function that solves a game for a
/// maximum search depth. It is a struct containing two parts:
/// (a) `opt_play` (optional): the optimal* next play, if it exists
/// (b) `outcome` (required): the resulting outcome
///
/// * Stylistic note: While it is true that `opt_play`, if present, will be an
/// optimal play, the first letter letters are not an abbreviation for
/// 'optimal`. I chose the prefix `opt_` as convention that means the type is
/// `Option<...>` and use this style across the code base.
///
/// A solver, for a given game and maximum search depth, may conclude one of
/// three things:
///
/// (A) the game is completed and there are no legal moves
/// (B1) the game is ongoing and an optimal move is found
/// (B2) the game is ongoing and an optimal move is not found
///
/// Here are the possible corresponding `Solution` values:
///
/// (A) Outcome { opt_play: None, outcome: Win { ... } } or
///     Outcome { opt_play: None, outcome: Tie { ... } }
///
/// (B1) Outcome { opt_play: Some(...), outcome: Win { ... } } or
///      Outcome { opt_play: Some(...), outcome: Tie { ... } }
///
/// (B2) Outcome { opt_play: None, outcome: Unknown { ... } }
///
/// -- Turns Required and Optimality --
///
/// For example, if the outcome is a 'win in N plays', this means that the
/// current player will beat an optimal opponent in no more than N turns
/// (i.e. plays). The beating may happen sooner if the opponent is non-optimal.
///
/// (Side note: Because I sometimes free-associate, I can't help but think of the saying
/// about good management: "The beatings will continue until morale improves."
/// This phrase may be appropos here; if a player's performance improves with
/// better morale, then the player chances of being beaten decrease as his
/// morale improves.)
///
/// (Comparative note: our approach here differs from other techniques, such as
/// reinforcement learning, that may capitalize on an opponent's imperfections
/// in order to win more quickly most of the time. However, to do so is a
/// gamble, to some degree. If an agent has learned that an opponent is not
/// optimal, there may be shortcuts to beating that opponent more
/// quickly. However, such an agent may be surprised from time to time if the
/// opponent's behavior changes from accident, experimentation, or learning.)
///
/// -- Examples --
///
/// Some specific examples, assuming optimal players:
///
/// 1. See turn 25 in the table below; it is X's move. Let's assume that X's
///    best move will ensure victory in 5 moves (counting the moves of both
///    players), so the 'outcome' of turn 25 is a 'win by X in 5'. In this kind
///    of situation (ie.e X is next to move and will guarantee victory in K
///    turns), K is always odd.
///
/// ```text
///       last                     next
/// turn  player  winner  outcome  player
/// ----  ------  ------  -------  ------
///    0  -       -       .        X
///    1  X       -       .        O
///   ..  .       -       .        .
///   ..  .       -       .        .
///   ..  .       -       .        .
///   25  O       -       Win X 5  X
///   31  X       -       Win X 4  O
///   32  O       -       Win X 3  X
///   33  X       -       Win X 2  O
///   34  O       -       Win X 1  X
///   35  X       X       Win X 0  -
/// ```
///
/// 2. If O reasons he cannot win or tie against an optimal opponent, then his
///    optimal sequence of moves will delay defeat as long as possible. For
///    example, look at the table above at turn 31; it is O's turn. The best O
///    can do is delay X's win by 4 moves, so the outcome of turn 31 is 'win by
///    X in 4'. Note that such a number must be even.
///
/// 3. If X's best move is to put O in a position so that a tie is optimal for O
///    (meaning that O can do no better than tie), then the outcome will be
///    'tie in 2', meaning that a tie is 2 plays away.
///
/// 4. If X is only willing/able to compute 10 moves, it is possible that a
///    solution will not be found. In such a situation, the optional next play
///    will be `None` and the outcome will be 'unknown for depth 10'.
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct Solution {
    /// The optimal next play (optional)
    pub opt_play: Option<Play>,
    /// The resulting outcome
    pub outcome: Outcome,
}
