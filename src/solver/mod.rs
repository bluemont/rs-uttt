/// Functions for solving the game (i.e. intelligent behavior).

use data::*;
use std::cmp::Ordering;

#[cfg(test)]
mod tests;

#[cfg(test)]
mod benchmarks;

// == data structures ==========================================================

/// A solution (`Solution`) is generated by a function that solves a game for a
/// maximum search depth. It is a struct containing two parts:
/// (a) `opt_play` (optional): the optimal* next play, if it exists
/// (b) `outcome` (required): the resulting outcome
///
/// * Stylistic note: While it is true that `opt_play`, if present, will be an
/// optimal play, the first letter letters are not an abbreviation for
/// 'optimal`. I chose the prefix `opt_` as convention that means the type is
/// `Option<...>` and use this style across the code base.
///
/// A solver, for a given game and maximum search depth, may conclude one of
/// three things:
///
/// (A) the game is completed and there are no legal moves
/// (B1) the game is ongoing and an optimal move is found
/// (B2) the game is ongoing and an optimal move is not found
///
/// Here are the possible corresponding `Solution` values:
///
/// (A) Outcome { opt_play: None, outcome: Win { ... } } or
///     Outcome { opt_play: None, outcome: Tie { ... } }
///
/// (B1) Outcome { opt_play: Some(...), outcome: Win { ... } } or
///      Outcome { opt_play: Some(...), outcome: Tie { ... } }
///
/// (B2) Outcome { opt_play: None, outcome: Unknown { ... } }
///
/// -- Turns Required and Optimality --
///
/// For example, if the outcome is a 'win in N plays', this means that the
/// current player will beat an optimal opponent in no more than N turns
/// (i.e. plays). The beating may happen sooner if the opponent is non-optimal.
///
/// (Side note: Because I sometimes free-associate, I can't help but think of the saying
/// about good management: "The beatings will continue until morale improves."
/// This phrase may be appropos here; if a player's performance improves with
/// better morale, then the player chances of being beaten decrease as his
/// morale improves.)
///
/// (Comparative note: our approach here differs from other techniques, such as
/// reinforcement learning, that may capitalize on an opponent's imperfections
/// in order to win more quickly most of the time. However, to do so is a
/// gamble, to some degree. If an agent has learned that an opponent is not
/// optimal, there may be shortcuts to beating that opponent more
/// quickly. However, such an agent may be surprised from time to time if the
/// opponent's behavior changes from accident, experimentation, or learning.)
///
/// -- Examples --
///
/// Some specific examples, assuming optimal players:
///
/// 1. See turn 25 in the table below; it is X's move. Let's assume that X's
///    best move will ensure victory in 5 moves (counting the moves of both
///    players), so the 'outcome' of turn 25 is a 'win by X in 5'. In this kind
///    of situation (ie.e X is next to move and will guarantee victory in K
///    turns), K is always odd.
///
/// ```text
///       last                     next
/// turn  player  winner  outcome  player
/// ----  ------  ------  -------  ------
///    0  -       -       .        X
///    1  X       -       .        O
///   ..  .       -       .        .
///   ..  .       -       .        .
///   ..  .       -       .        .
///   25  O       -       Win X 5  X
///   31  X       -       Win X 4  O
///   32  O       -       Win X 3  X
///   33  X       -       Win X 2  O
///   34  O       -       Win X 1  X
///   35  X       X       Win X 0  -
/// ```
///
/// 2. If O reasons he cannot win or tie against an optimal opponent, then his
///    optimal sequence of moves will delay defeat as long as possible. For
///    example, look at the table above at turn 31; it is O's turn. The best O
///    can do is delay X's win by 4 moves, so the outcome of turn 31 is 'win by
///    X in 4'. Note that such a number must be even.
///
/// 3. If X's best move is to put O in a position so that a tie is optimal for O
///    (meaning that O can do no better than tie), then the outcome will be
///    'tie in 2', meaning that a tie is 2 plays away.
///
/// 4. If X is only willing/able to compute 10 moves, it is possible that a
///    solution will not be found. In such a situation, the optional next play
///    will be `None` and the outcome will be 'unknown for depth 10'.
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct Solution {
    /// The optimal next play (optional)
    pub opt_play: Option<Play>,
    /// The resulting outcome
    pub outcome: Outcome,
}

/// The computed outcome of a game; either:
/// 1. A win for player X in some number of plays
/// 2. A win for player O in some number of plays
/// 3. A tie in some number of turns
/// 4. Not one of the above, so unknown.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum Outcome {
    Win { player: Player, turns: Count },
    Tie { turns: Count },
    Unknown { turns: Count },
}

// == data accessors ===========================================================

impl Outcome {
    pub fn turns(self) -> Count {
        match self {
            Outcome::Win { player: _, turns: t } => t,
            Outcome::Tie { turns: t } => t,
            Outcome::Unknown { turns: t } => t,
        }
    }
}

// == solving functions ========================================================

impl Game {
    /// Returns the solution for a given game and depth. This function looks
    /// ahead for a number of moves (specified by `depth`). If there are no
    /// valid moves, returns a solution where the optional play is `None` and
    /// the outcome is either a win or a tie.
    pub fn solve(&self, depth: Count) -> Solution {
        if depth == 0 {
            self.solve_zero_depth()
        } else if depth > 0 {
            self.solve_positive_depth(depth)
        } else {
            panic!("Internal Error: depth < 0");
        }
    }

    /// Returns the solution for depth == 0.
    fn solve_zero_depth(&self) -> Solution {
        match self.state() {
            GameState::Won(player) => Solution {
                opt_play: None,
                outcome: Outcome::Win { player: player, turns: 0 },
            },
            GameState::Tied => Solution {
                opt_play: None,
                outcome: Outcome::Tie { turns: 0 },
            },
            GameState::Ongoing => Solution {
                opt_play: None,
                outcome: Outcome::Unknown { turns: 0 },
            },
        }
    }

    /// Returns the solution for a given game and depth.
    ///
    /// It works by first solving a simpler case, `depth - 1`. If the solution
    /// is dominant, return it. (For example, if the specified depth is 4 and a
    /// win can be found in 3 moves, there is no need to search 4 levels deep.)
    ///
    /// Alternatively, if the `depth - 1` solution is not dominant, then build a
    /// vector of possible solutions for all possible moves, with a solution
    /// depth of `depth`. Merge in the `depth - 1` solution if it has some
    /// value. (Since it might be the optimal solution, even though it was not
    /// dominant.)  Finally, return the best solution.
    fn solve_positive_depth(&self, depth: Count) -> Solution {
        let solution = self.solve(depth - 1);
        match solution.dominant(self.next_player(), depth) {
            Some(dom) => dom,
            None => {
                let player = self.next_player().unwrap();
                let solutions = merge_solutions(
                    solution.if_optimal(), self.candidate_solutions(depth));
                best_solution(player, solutions)
            }
        }
    }

    /// Returns candidate (possible) solutions for a given depth.
    ///
    /// Builds a vector of solutions by calculating all valid plays from the
    /// current game, computing the next game state for each play, and solving
    /// each resulting game to a depth of `depth - 1`. (Note: It is essential to
    /// decrease the depth by one as a counterbalance to advancing the game by
    /// one play. Otherwise, this function would not effectively be bounded by
    /// the depth argument.)
    fn candidate_solutions(&self, depth: Count) -> Vec<Solution> {
        self.valid_plays().iter().map(|&play| {
            let mut game = self.clone();
            game.play(play);
            game.solve(depth - 1).futurize(play)
        }).collect::<Vec<Solution>>()
    }
}

impl Solution {
    /// If a given solution is dominant, return it. A dominant solution is one
    /// good enough such that there is no need in searching for others.
    fn dominant(self, opt_player: Option<Player>, depth: Count)
                -> Option<Solution> {
        match self.outcome {
            Outcome::Win { player: p, turns: t } => {
                if t == 0 {
                    Some(self)
                } else if t < depth {
                    match opt_player {
                        Some(player) if p == player => Some(self),
                        _ => None,
                    }
                } else {
                    None
                }
            },
            Outcome::Tie { turns: t } if t == 0 => Some(self),
            _ => None,
        }
    }
}

// == helpers for solving functions ============================================

/// Returns the best solution from given solutions for a player.
fn best_solution(p: Player, ss: Vec<Solution>) -> Solution {
    let mut xs = ss.clone();
    xs.sort_by(|a, b| Solution::compare(p, *a, *b));
    xs.first().unwrap().clone()
}

impl Solution {
    /// If the solution contains an optimal move, returns the solution wrapped
    /// in `Some`; otherwise, returns `None`. (Put another way, if
    /// `solution.opt_play` has some value, return `Some(solution)`; otherwise,
    /// return `None`.)
    fn if_optimal(self) -> Option<Solution> {
        self.opt_play.and(Some(self))
    }
}

/// Returns the combined (merged) solution vector from an optional solution and
/// a vector of solutions.
fn merge_solutions(opt_solution: Option<Solution>, solutions: Vec<Solution>)
                   -> Vec<Solution> {
    match opt_solution {
        None => solutions,
        Some(solution) => {
            let mut ss = solutions;
            ss.push(solution);
            ss.clone()
        },
    }
}

// == 'modifiers' ==============================================================

impl Solution {
    /// Returns an 'updated' solution shifted into the future. Sets the play
    /// field and increments the associated count on the outcome field.
    fn futurize(self, play: Play) -> Solution {
        Solution {
            opt_play: Some(play),
            outcome: self.outcome.inc(),
        }
    }
}

impl Outcome {
    /// Returns an 'updated' outcome by incrementing the 'turns' for the given
    /// outcome.
    fn inc(self) -> Outcome {
        match self {
            Outcome::Win { player: p, turns: k } =>
                Outcome::Win { player: p, turns: k + 1 },
            Outcome::Tie { turns: k } =>
                Outcome::Tie { turns: k + 1 },
            Outcome::Unknown { turns: k } =>
                Outcome::Unknown { turns: k + 1 },
        }
    }
}

// == comparators ==============================================================

impl Solution {
    /// Compare two solutions.
    fn compare(p: Player, a: Solution, b: Solution) -> Ordering {
        let play_a = a.opt_play.unwrap();
        let play_b = b.opt_play.unwrap();
        if play_a == play_b {
            let turns_a = a.outcome.turns();
            let turns_b = b.outcome.turns();
            turns_b.cmp(&turns_a)
        } else {
            Outcome::compare(p, a.outcome, b.outcome)
        }
    }
}

impl Outcome {
    /// Compare two outcomes from the point of view of the given player.
    fn compare(p: Player, a: Outcome, b: Outcome) -> Ordering {
        let o = p.opponent();
        match (a, b) {
            (Outcome::Win { player: p1, turns: t1 },
             Outcome::Win { player: p2, turns: t2 }) => {
                if p1 == p && p2 == o {
                    Ordering::Less // prefer to win, not lose
                } else if p1 == o && p2 == p {
                    Ordering::Greater // prefer to win, not lose
                } else if p1 == p && p2 == p {
                    t1.cmp(&t2) // prefer to win sooner, not later
                } else { // p1 == o && p2 == o
                    t2.cmp(&t1) // prefer to lose later, not sooner
                }
            },
            (Outcome::Win { player: p1, turns: _ },
             Outcome::Tie { turns: _ }) => {
                if p1 == p {
                    Ordering::Less // prefer to win, not tie
                } else { // p1 == o
                    Ordering::Greater // prefer to tie, not lose
                }
            },
            (Outcome::Tie { turns: _ },
             Outcome::Win { player: p2, turns: _ }) => {
                if p2 == o {
                    Ordering::Less // prefer to tie, not lose
                } else { // p2 == p
                    Ordering::Greater // prefer to win, not tie
                }
            },
            (Outcome::Win { player: p1, turns: _ },
             Outcome::Unknown { turns: _ }) => {
                if p1 == p {
                    Ordering::Less // prefer to win over the unknown
                } else { // p1 == o
                    Ordering::Greater // prefer the unknown over losing
                }
            },
            (Outcome::Unknown { turns: _ },
             Outcome::Win { player: p2, turns: _ }) => {
                if p2 == o {
                    Ordering::Less // prefer the unknown over losing
                } else { // p2 == p
                    Ordering::Greater // prefer to win over the unknown
                }
            },
            (Outcome::Tie { turns: t1 },
             Outcome::Tie { turns: t2 }) => {
                t2.cmp(&t1) // prefer to tie later, not sooner
            },
            (Outcome::Tie { turns: _ },
             Outcome::Unknown { turns: _ }) => {
                Ordering::Greater // prefer the unknown over the tie
            },
            (Outcome::Unknown { turns: _ },
             Outcome::Tie { turns: _ }) => {
                Ordering::Less // prefer the unknown over the tie
            },
            (Outcome::Unknown { turns: t1 },
             Outcome::Unknown { turns: t2 }) => {
                t2.cmp(&t1) // Prefer the unknown later, not sooner
            },
        }
    }
}
